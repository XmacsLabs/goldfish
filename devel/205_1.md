# [205_1] 为 Goldfish 添加协程调度与控制能力

## 如何检测

运行协程相关测试：

```sh
bin/goldfish tests/goldfish/liii/coroutine-test.scm
```

所有用例通过即表示协程的创建、调度以及控制 API 工作正常。

## 2025/11/25

## What

- 在 C++ 层基于 TBOX 的 coroutine/scheduler 实现协程调度：
	- 使用 `tb_co_scheduler_init / tb_co_scheduler_loop / tb_co_scheduler_exit` 管理调度器；
	- 使用 `tb_coroutine_start` 启动协程，并通过统一的 `coroutine_run` 调用 Scheme 闭包；
	- 使用 `s7_gc_protect / s7_gc_unprotect_at` 保护协程闭包，避免在协程执行期间被 GC 回收。
- 提供基础 API：
	- `g_coroutine-dispatch`：创建调度器并执行顶层协程及其派生的所有协程，直到全部完成；
	- `g_coroutine-create`：在当前调度器下立即创建并启动一个新的协程。
- 提供协程控制 API：
	- `g_coroutine-yield`：当前协程主动让出执行权，由调度器切换到其他协程；
	- `g_coroutine-sleep`：当前协程非阻塞睡眠指定毫秒数，醒来后继续执行；
- 在 Scheme 层增加 `(liii coroutine)` 库封装上述 API：
	- `coroutine-dispatch` / `coroutine-create`
	- `coroutine-yield` / `coroutine-sleep`
- 为上述功能添加测试：`tests/goldfish/liii/coroutine-test.scm`：
	- 验证 `coroutine-dispatch` 能执行所有派生协程并正确汇总副作用（加和、列表构造等）；
	- 验证 `coroutine-yield` 的交替执行顺序；
	- 验证 `coroutine-sleep` 的非阻塞行为以及不同睡眠时间下的唤醒顺序；

## Why

- 为 Goldfish 提供一种轻量级的协作式并发原语，便于在脚本中组织复杂的异步/并发逻辑；
- 通过 TBOX 的 coroutine/scheduler 复用成熟实现，避免自行管理栈切换和事件轮询；
- 在 Scheme 层暴露统一的 `(liii coroutine)` API，使用户可以用少量原语表达：
	- 顺序执行 + 并发创建（`dispatch`/`create`）；
	- 主动让出（`yield`）和按时间驱动的挂起（`sleep`）；

