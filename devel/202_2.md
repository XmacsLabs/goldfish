# [202_2] rich-vector 性能测试对比

## 任务相关的代码文件
- `bench/rich-vector.scm` - Scheme 版本的 rich-vector 性能测试
- `bench/rich_vector.py` - Python 版本的数组求和性能测试
- `bench/vector-traversal-methods.scm` - 向量遍历方法性能对比测试

## 如何测试

### 完整的性能测试流程

性能测试需要按照特定的顺序执行，以确保获得准确的性能对比数据。

#### 1. 运行 Scheme 性能测试
首先运行 Scheme 测试来获取最新的性能基准数据：

```bash
# 构建项目
bin/goldfish build

# 运行 rich-vector 性能测试
bin/goldfish bench/rich-vector.scm
```

测试输出示例：
```
rich-vector%empty%length:    0.113186 秒
vector-length (vector):       0.001267 秒
rich-vector-sum-only (length=100):   0.317300 秒
vector-sum-only (length=100):        0.109263 秒
```

#### 2. 更新 Python 测试脚本
根据 Scheme 测试结果，更新 Python 脚本中的性能对比数据：

编辑 `bench/rich_vector.py`，更新以下行中的时间数据：
```python
print(f"Scheme vector-sum-only: 0.105557 秒 (apply+vector->list)")
print(f"Scheme rich-vector-sum-only: 0.315977 秒")
```

#### 3. 运行 Python 性能测试
使用完整的路径运行 Python 测试：

```bash
python3 bench/rich_vector.py
```

测试输出示例：
```
Python 数组求和性能测试 (长度=100) - 只计算求和操作
============================================================
测试数组长度: 100, 总和: 44649
list-sum-manual-only:   0.139625 秒 (50000 iterations)
list-sum-builtin-only:  0.028252 秒 (50000 iterations)

性能对比:
手动循环 vs 内置sum: 4.94x

与 Scheme 对比 (只计算求和操作，50000次迭代):
Python 手动循环: 0.139625 秒
Python 内置sum:  0.028252 秒
Scheme vector-sum-only: 0.105557 秒 (apply+vector->list)
Scheme rich-vector-sum-only: 0.315977 秒

性能倍数对比:
Python手动循环 / Scheme vector-sum: 1.32x
Python内置sum / Scheme vector-sum: 0.27x
Python手动循环 / Scheme rich-vector-sum: 0.44x
Python内置sum / Scheme rich-vector-sum: 0.09x
Scheme rich-vector-sum / Scheme vector-sum: 2.99x
```

### 测试注意事项

1. **执行顺序很重要**：必须先运行 Scheme 测试获取基准数据，再运行 Python 测试进行对比

2. **使用完整路径**：运行 Python 测试时使用 `python3 bench/xxx.py` 格式，避免路径问题

3. **多次运行取平均值**：建议每个测试运行 2-3 次，取平均值以获得更稳定的性能数据

4. **环境一致性**：确保测试环境相同，避免后台任务影响测试结果

5. **数据更新**：当 Scheme 实现优化后，需要及时更新 Python 脚本中的对比数据

### 测试目标

通过这个测试流程，我们可以：
- 比较 `rich-vector` 和原生 `vector` 的性能差异
- 对比 Scheme 和 Python 在数值计算方面的性能
- 验证不同向量遍历方法的效率
- 为性能优化提供数据支持

## 性能对比结果

### 1. rich-vector vs vector 性能对比

| 操作类型 | rich-vector | vector | 性能差异 |
|---------|------------|--------|----------|
| 空向量长度 | 0.113186 秒 | 0.001267 秒 | **89倍** |
| 向量求和 (长度=100) | 0.317300 秒 | 0.109263 秒 | **2.9倍** |

**关键发现**：
- `rich-vector` 的对象创建和方法调用开销很大
- 对于空向量操作，性能差异尤为显著
- 对于实际数据操作，性能差异相对较小但仍明显

### 2. Scheme vs Python 性能对比

| 实现方式 | 运行时间 | 相对性能 |
|---------|---------|----------|
| **Python 内置sum** | 0.028252 秒 | **最快** |
| **Scheme vector-sum** | 0.105557 秒 | 3.74x 慢 |
| **Python 手动循环** | 0.139625 秒 | 4.94x 慢 |
| **Scheme rich-vector-sum** | 0.315977 秒 | 11.18x 慢 |

**关键发现**：
- Python 的内置 `sum()` 函数性能最佳
- Scheme 的原生向量操作优于 Python 手动循环
- `rich-vector` 的面向对象封装带来显著性能开销

### 3. 向量遍历方法性能对比

| 方法 | 运行时间 | 相对性能 |
|------|---------|----------|
| **apply + vector->list** | 0.103827 秒 | **最快** |
| **vector-for-each** | 0.109196 秒 | 1.05x 慢 |
| **do 循环** | 0.167757 秒 | 1.62x 慢 |
| **let loop** | 0.205878 秒 | 1.98x 慢 |
| **vector-map** | 0.245969 秒 | 2.37x 慢 |
| **make-iterator** | 0.363836 秒 | 3.50x 慢 |

## 结论

### 主要结论

1. **rich-vector 性能开销**：`rich-vector` 相比原生 `vector` 有显著的性能开销，特别是在对象创建和简单操作方面。

2. **语言性能对比**：Python 的内置函数在数值计算方面表现出色，但 Scheme 的原生向量操作在优化后也能达到很好的性能。

3. **遍历方法选择**：在 S7 Scheme 中，`apply + vector->list` 是遍历数值向量的最快方法，而 `vector-for-each` 是性能最好的专用迭代器。

### 优化建议

1. **性能敏感场景**：在性能要求高的场景中，优先使用原生 `vector` 操作而非 `rich-vector`。

2. **向量遍历**：对于纯数值向量的求和操作，推荐使用 `(apply + (vector->list vec))`。

3. **API 设计权衡**：`rich-vector` 提供了更好的 API 设计，但需要权衡性能开销，适合对性能要求不高的应用场景。

4. **跨语言选择**：对于数值密集型计算，Python 的内置函数是很好的选择；对于需要精细控制的场景，Scheme 的原生操作也很有竞争力。

### 后续工作

- 继续优化 `rich-vector` 的实现，减少方法调用开销
- 探索更多的向量遍历优化方法
- 扩展性能测试覆盖更多的操作类型和数据结构