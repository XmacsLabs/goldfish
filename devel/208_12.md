# [208_12] 实现 utf8->utf16le

## 任务相关的代码文件
- src/liii/unicode.scm
- tests/liii/unicode.scm

## 如何测试
```bash
xmake config --yes
xmake b goldfish
bin/goldfish tools/lint.scm goldfish/liii/unicode.scm
bin/goldfish tools/lint.scm tests/goldfish/liii/unicode-test.scm
bin/goldfish tests/goldfish/liii/unicode-test.scm
```

## 2025-10-20 实现 bytevector-utf16le-advance

### What
实现 `bytevector-utf16le-advance` 函数，用于在 UTF-16LE 编码的字节向量中前进到下一个字符的起始位置。

1. 实现 UTF-16LE 编码的字符边界检测功能
2. 支持基本多文种平面字符（2字节编码）和辅助平面字符（4字节编码，代理对）
3. 正确处理边界条件和无效序列

### Why
需要提供 UTF-16LE 编码的字符遍历功能，这是 Unicode 编码处理功能的重要组成部分，与现有的 `bytevector-advance-utf8` 函数形成对称设计。

### How
实现思路：
- 根据 UTF-16LE 编码规则检测字符边界
- 对于基本多文种平面字符，前进 2 个字节
- 对于代理对（高代理+低代理），前进 4 个字节
- 对于无效序列，返回当前位置
- 支持可选的结束位置参数

## 2025-10-20 实现 utf8->utf16le

### What
实现 `utf8->utf16le` 函数，用于将 UTF-8 编码的字节向量转换为 UTF-16LE 编码的字节向量。

1. 使用 `bytevector-advance-utf8` 遍历 UTF-8 字节向量
2. 在每次循环中：
   - 使用 `utf8->codepoint` 将 UTF-8 字节转换为 Unicode 码点
   - 使用 `codepoint->utf16le` 将码点转换为 UTF-16LE 字节向量
3. 将每次循环得到的 UTF-16LE 字节向量拼接起来，形成最终结果

### Why
需要提供 UTF-8 到 UTF-16LE 的编码转换功能，这是 Unicode 编码转换功能的重要组成部分。

### How
实现思路：
- 利用现有的 `bytevector-advance-utf8` 函数来遍历 UTF-8 字节向量
- 在遍历过程中，通过 `utf8->codepoint` 和 `codepoint->utf16le` 进行编码转换
- 使用字节向量拼接操作来构建最终的 UTF-16LE 结果
- 这种方法可以正确处理多字节的 UTF-8 字符和代理对（surrogate pairs）