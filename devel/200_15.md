# 200_15 bin/format
## 相关文件
新增或者修改：
```
bin/format
goldfish/liii/pp.scm
goldfish/liii/pp-comment.scm
goldfish/liii/pretty-print.scm
tests/goldfish/liii/pp-test.scm
tests/goldfish/liii/pp-comment-test.scm
tools/format.scm
devel/200_15.md
```

仅读取：
```
goldfish/liii/base.scm
goldfish/liii/string.scm
goldfish/liii/sys.scm
goldfish/liii/path.scm
goldfish/scheme/write.scm
goldfish/scheme/base.scm
tests/goldfish/liii/string-test.scm
```

## 如何测试
测试前先构建
```
xmake config --yes
xmake b goldfish
bin/lint goldfish/liii/pp.scm
bin/lint tests/goldfish/liii/pp-test.scm
bin/goldfish tests/goldfish/liii/pp-test.scm
```

## 空行和注释保留方案

我们将采用**转换式保留**方案：把空行和注释都转换为特殊的Scheme表达式，这样它们就能像普通代码一样被Scheme解析器处理，同时又能被格式化工具识别并还原。

### 空行的处理方案
空行将作为特殊的注释表达式保留，采用以下格式：
```scheme
(*PP_EMPTY_LINE*)
```

### 注释的转换方案
### 单行注释
- 原始格式：`; 这是注释`
- 转换格式：`(*PP_SINGLE_COMMENT* "这是注释")`

### 尾部注释
- 原始格式：`(define x 1) ; 初始化变量`
- 转换格式：`(define x 1) (*PP_TAIL_COMMENT* "初始化变量")`

### 多行注释
- 原始格式：
```scheme
#|这是多行
  注释的第二行|#
```
- 转换格式：`(*PP_MULTI_COMMENT* "这是多行" "注释的第二行")`

#### 空字符串处理规则
`(*PP_MULTI_COMMENT*)` 支持空字符串参数，用于控制输出格式：
- **第一个参数为空字符串**：在 `#|` 后添加换行符
  - `(*PP_MULTI_COMMENT* "" "line2")` → `#|\nline2|#`
- **最后一个参数为空字符串**：在 `|#` 前添加换行符  
  - `(*PP_MULTI_COMMENT* "line1" "")` → `#|line1\n|#`
- **两个参数都为空字符串**：在 `#|` 和 `|#` 之间添加两个换行符
  - `(*PP_MULTI_COMMENT* "" "")` → `#|\n\n|#`

空字符串参数提供了灵活的多行注释格式化控制，使得注释内容的布局更加美观。

## 实现步骤
1. **预处理阶段**：`pp-parse` 函数将读取原始代码，识别空行和各种注释，转换成相应的特殊表达式
2. **格式化阶段**：Scheme的pretty-printer将正常处理这些特殊表达式
3. **后处理阶段**：格式化完成后，将特殊表达式还原为原始的空行和注释格式

### 关键特点
- **无缝集成**：特殊表达式看起来像是合法的Scheme函数调用，不会破坏解析
- **位置保持**：通过转换方式保留了空行和注释的原始位置信息
- **可逆操作**：可以轻松地从特殊表达式还原到原始的注释格式
- **扩展性强**：能够处理复杂的嵌套注释和多行空行情况

### 示例转换
**输入原始代码：**
```scheme
; 定义一个待处理的列表
(define lst '(1 2 3)) ; 列表元素

; 处理每个元素
(for-each
  (lambda (x) x) ; 恒等函数
  lst)
```

**转换后的代码：**
```scheme
(*PP_SINGLE_COMMENT* "定义一个待处理的列表")
(define lst '(1 2 3)) (*PP_TAIL_COMMENT* "列表元素")
(*PP_EMPTY_LINE*)
(*PP_SINGLE_COMMENT* "处理每个元素")
(for-each
  (lambda (x) x) (*PP_TAIL_COMMENT* "恒等函数")
  lst)
```

这样的方案既能使用已有的格式化功能，又能完整保留代码的结构和可读性。

## pp-parse 的ASCII状态转移设计

`pp-parse`函数需要识别并处理以下状态：

### 状态机设计
```
                    ┌─────────────────┐
                    │    START        │
                    └─────────────────┘
                            │
                            ├─空格/制表─→[处理空白]
                            │
                            ├─\n────────→[处理空行]
                            │
                            ├─;─────────→[单行注释]
                            │
                            ├─#|────────→┌─────────────────┐
                            │            │  MULTI_COMMENT  │◄────┐
                            │            └─────────────────┘     │
                            │                    │               │
                            │                    ├─|#───────────┘
                            │                    └─其他字符─────┐
                            │                                   │
                            ├─"─────────→┌─────────────────┐   │
                            │            │   STRING        │◄──┘
                            │            └─────────────────┘
                            │                    │
                            │                    ├─"───────────┐
                            │                    │            │
                            │                    └─#\;─────→[字符串中的转义字符]
                            │
                            └─其他字符─→[收集代码]
```

### 详细状态描述

#### 状态：START
- **入口**: 初始状态
- **行为**: 
  - 读入字符，根据类型转换到对应状态
  - 在处理空行时：维护空行计数器
  - 在处理注释时：积累注释内容

#### 状态：NORMAL (常规代码)
```
    [读入字符]          [输出结果]
 START ───────┐       NORMAL ───────► 输出代码片段
        ┌─────┘                 │
        │                      [继续处理]
        │                       │
        └─; 触发─────→COMMENT    └─#|触发───→MULTI_COMMENT
                     STRING     
```

#### 状态：COMMENT (单行注释)
```
       行末尾|              [注释结束]
COMMENT ──────────► START
    │                   ↓
    │              输出(*PP_SINGLE_COMMENT* "内容")
    │                   │
    └─;收集内容传承──┘
```

#### 状态：MULTI_COMMENT (多行注释)
```
      |#标识        [登出]
MULTI_COMMENT ───────► START
      │                  │
      │            输出(*PP_MULTI_COMMENT* "行1" "行2" ...)
      │                  │
      └─收集内容───┘
```

#### 状态：STRING (字符串)
```
        " 封闭         [字符串结束]
  STRING ─────────► NORMAL
      │                  │
      │            输出字符串内容
      │                  │
      └─处理转义字符   
         ├─#\\n──→特殊处理
         ├─#\\t──→特殊处理
         ├─#\\r──→特殊处理
         └─#\\;──→保持;字符
```

### 转义字符处理
```
         "字符串开始"
    常规字符        转义序列
"hello world" │ "hello#\\world"  #\\ = \
              │              
"#\\;"        = ";"           #\;特殊处理
"foo#\\bar#\\;" = "foobar;"
```

### 边界情况处理
- **混合状态**: 多行注释嵌套字符串
- **特殊对齐**: 尾部注释与代码对齐
- **空行计数**: 连续空行的压缩策略
- **Unicode**: 支持多字节字符的同步模式

### ASCII状态表
```
State    Char     Next     Action
─────────────────────────────────
START    ' '      START    跳过空格
START    '\n'     START    记录空行
START    ';'      COMMENT  开始单行注释（空白判断在前）
COMMENT  '\n'     START    输出注释宏 (*PP_SINGLE_COMMENT* "内容")
START    '"'      STRING   开始字符串
STRING   '"'      START    输出字符串
STRING   '\\'     ESCAPE   
ESCAPE   '*'      STRING   任何转义字符
START    '#|'     MULTI    开始多行注释
MULTI    '|#'     MULTI-END 多行注释结束
MULTI-END '\n'    START    输出多行注释宏
MULTI    其他     MULTI    继续收集多行注释
START    其他     NORMAL   开始收集正常代码
NORMAL   ';'      COMMENT  检查尾部注释（需要前置内容）
NORMAL   '#|'     MULTI    开始多行注释
NORMAL   '"'      STRING   开始字符串
NORMAL   '\n'     START    行结束，回到开始状态
NORMAL   其他     NORMAL   继续收集正常代码
```

### 新增的单行注释状态转换
需要补充实现单行注释的状态转移：
1. **start → comment**: 以`;`开头的行首注释开始
2. **comment → start**: 单行注释结束后回到开始状态
3. **comment → end**: 单行注释处理完后的终止判断
4. **normal → comment**: 代码后的尾部注释识别

### pp_post 字符状态机设计方案（不依赖read）

pp_post需要实现真正的字符级状态机，实现PP_SINGLE_COMMENT等表达式的识别与转换：

#### 状态设计：
- **start**: 起始状态，等待发现特殊表达式
- **single-comment**: 发现PP_SINGLE_COMMENT，开始提取字符串内容
- **multi-comment**: 发现PP_MULTI_COMMENT，开始收集所有行
- **newline**: 发现PP_NEWLINE，开始提取数字参数
- **normal**: 普通字符直接输出

#### 转换规则：
```
状态转移图：

start --"(*PP_SINGLE_COMMENT*"--> single-comment 
start --"(*PP_MULTI_COMMENT*"--> multi-comment
start --"(*PP_NEWLINE*"--> newline
start --其他字符--> normal(直接输出)

single-comment --完成字符串--> start (输出"; "+内容)
multi-comment --完成收集--> start (输出多行注释格式)
newline --完成数字--> start (输出对应换行)
normal --特殊关键字--> 相应状态
```

#### 字符级处理函数：

```scheme
; PP_SINGLE_COMMENT处理的字符级状态机
(next-state-from-start-post str pos result)
- 检测 "(*PP_SINGLE_COMMENT*" 字符串前缀
- 状态转换为 single-comment

(next-state-from-single-comment-post str pos result)
- 提取双引号内的字符串内容
- 将"(*PP_SINGLE_COMMENT* \"内容\" )"转换为"; 内容\n"

; PP_MULTI_COMMENT处理的字符级状态机  
(next-state-from-multi-comment-post str pos result)
- 提取每个字符串参数并组合
- 生成"#|\n行1\n行2|#"

; PP_NEWLINE处理的字符级状态机
(next-state-from-newline-post str pos result)
- 提取数字参数n
- 生成n个换行符

; 辅助函数(纯字符操作):
(find-paren-end str start)    - 找到匹配的右括号位置  
(extract-string-content str start end) - 提取双引号字符串内容
(extract-multi-comment-lines str start end) - 提取多个字符串参数
(extract-newline-count str start end) - 提取数字参数
```

#### 无read的限制：
- 字符串内容识别：扫描双引号"内容"  
- 数字参数识别：扫描数字字符序列
- 括号匹配：使用栈的方式计算匹配位置
- 错误处理：不完整的表达式保持原样
