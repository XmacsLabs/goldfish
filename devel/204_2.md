# argh-based argparse

## 如何测试？

正常编译
```sh
xmake f -v -y
xmake b goldfish
```

测试各种参数
```sh
./bin/goldfish --help
./bin/goldfish goldfish/liii/alist.scm -i
```

```sh
./bin/goldfish -i -e '(define ans 42)'

gf> ans
 = 42
```

### 更新后行为

会进入 REPL
- `goldfish`
- `goldfish -l FILE`
- `goldfish -l FILE -e EXP`
- `goldfish -l FILE -e EXP -i`
- `goldfish FILE1 FILE2 -i`

不会进入 REPL
- `goldfish FILE`
- `goldfish --help / -h`
- `goldfish --version / -v`

可在进入 REPL 前使用 --load, --eval 以及位置参数 FILE eval 一些代码

import 特定模块
```
./bin/goldfish -e "(import (liii alist))"
...
gf> ,a alist
alist-cons (procedure) (null)
alist? (procedure) (null)
alist-ref (procedure) (null)
alist-ref/default (procedure) (null)
vector->alist (procedure) (null)
(liii alist) (procedure) (null)
gf>
```

```
> cat x.scm
(define ans 42)
> ./bin/goldfish -l x.scm 
 * x.scm evaluated
...
gf> ans
 = 42
gf>
```

## 2025/07/30

### What

- 新增 argh xmake 本地仓库。
- 新增 3rdparty/argh/，维护修改后的 argh。
- 在 `src/goldfish.hpp` 中新增基于修改后 argh 的 argparse 实现。
- 更新了 CI 中的 CLI 调用，原 `goldfish -l FILE` 会自动进入 REPL，应使用 `goldfish FILE`


### Why

[argh!](https://github.com/adishavit/argh) 是 500 行左右的 header-only C++(11) 库，BSD-3 协议（允许商用），足够轻量且跨平台。相比较原来手动的 arg parse，更容易维护和扩展，且功能更强。

支持
- 长短参数 `--eval`, `-e`
- 任意数量的 FILE
- 无 FILE 时自动进入 REPL（如果 REPL 可用）
- eval 和 load 任意表达式后再进入 REPL

