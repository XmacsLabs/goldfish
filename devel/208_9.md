# [208_9] 实现 codepoint 和 utf16le 的转换

## 任务相关的代码文件
- `goldfish/liii/unicode.scm` - unicode 模块实现文件
- `tests/goldfish/liii/unicode-test.scm` - unicode 模块测试文件

## 如何测试
一般先构建，再lint，最后运行测试用例。

```bash
# 构建项目
xmake config --yes
xmake b goldfish

# 代码检查
bin/lint goldfish/liii/unicode.scm
bin/lint tests/goldfish/liii/unicode-test.scm

# 运行测试
bin/goldfish -m r7rs tests/goldfish/liii/unicode-test.scm
```

## 2025-10-20 实现 codepoint 和 utf16le 的转换

### What
实现 Unicode 码点与 UTF-16LE 编码之间的转换函数：

1. 实现 `codepoint->utf16le` 函数，将 Unicode 码点转换为 UTF-16LE 编码的字节向量
2. 实现 `utf16le->codepoint` 函数，将 UTF-16LE 编码的字节向量转换为 Unicode 码点
3. 添加完整的单元测试用例，覆盖各种编码情况和边界条件
4. 实现与现有 UTF-8 和 UTF-16BE 转换函数的互逆操作验证

### Why
UTF-16LE 是小端字节序的 UTF-16 编码格式，在 Windows 系统和许多应用程序中广泛使用。实现这些函数可以：

- 提供完整的 Unicode 编码转换支持，包括小端字节序
- 支持 UTF-16LE 格式的文件读写，特别是 Windows 平台
- 为跨平台和跨编码格式的数据处理提供完整的基础
- 完善 Unicode 模块的功能完整性，支持所有主流 Unicode 编码格式

### How
- `codepoint->utf16le` 根据码点大小决定使用单个码元还是代理对，并以小端字节序存储
- `utf16le->codepoint` 根据字节序列判断是否包含代理对，并正确处理小端字节序
- 实现 UTF-16LE 编码的验证和错误处理
- 使用测试驱动开发方法，先写测试用例再实现功能
- 保持与现有 UTF-8 和 UTF-16BE 转换函数的一致性