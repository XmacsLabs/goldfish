# [210_7] 实现set

## 任务相关的代码文件
- goldfish/liii/set.scm
- goldfish/srfi/srfi-113.scm
- tests/goldfish/liii/set-test.scm

## 如何测试
```bash
bin/goldfish tests/goldfish/liii/set-test.scm
bin/lint goldfish/liii/set.scm
bin/lint goldfish/srfi/srfi-113.scm
bin/lint tests/goldfish/liii/set-test.scm
```

## 2026/01/28 实现 set->list 与 list->set! 函数
### What
在 (liii set) 模块中实现 set->list 与 list->set! 函数，并在测试文件中新增相应的注释和测试用例。

1. 在 goldfish/srfi/srfi-113.scm 中实现 set->list 与 list->set! 函数并添加到导出列表
2. 在 goldfish/liii/set.scm 的导出列表中添加 set->list 与 list->set! 函数
3. 在 tests/goldfish/liii/set-test.scm 中添加 set->list 与 list->set! 的文档注释和测试用例

### Why
set->list 便于将 set 转换为列表进行遍历或序列化；list->set! 用于将列表元素并入已有 set，重复元素会被去重。

### How
1. set->list 直接返回 set 的元素列表（顺序未指定）
2. list->set! 线性遍历列表并将元素加入 set
3. 在测试中覆盖空列表、比较器一致性与类型错误场景

## 2026/01/28 实现 set-partition 与 set-partition! 函数
### What
在 (liii set) 模块中实现 set-partition 与 set-partition! 函数，并在测试文件中新增相应的注释和测试用例。

1. 在 goldfish/srfi/srfi-113.scm 中实现 set-partition 与 set-partition! 函数并添加到导出列表
2. 在 goldfish/liii/set.scm 的导出列表中添加 set-partition 与 set-partition! 函数
3. 在 tests/goldfish/liii/set-test.scm 中添加 set-partition 与 set-partition! 的文档注释和测试用例

### Why
set-partition 返回两个新 set，分别包含满足与不满足 predicate 的元素；set-partition! 提供可变版本，并返回匹配与不匹配的两个集合。

### How
1. set-partition 创建两个与原 set 相同比较器的新 set
2. 遍历原 set 元素，按 predicate 结果分别写入两个新 set
3. set-partition! 线性遍历原 set，将不满足 predicate 的元素收集到新 set，并从原 set 移除
4. 返回两个值：匹配集合与不匹配集合

## 2026/01/28 实现 set-remove 与 set-remove! 函数
### What
在 (liii set) 模块中实现 set-remove 与 set-remove! 函数，并在测试文件中新增相应的注释和测试用例。

1. 在 goldfish/srfi/srfi-113.scm 中实现 set-remove 与 set-remove! 函数并添加到导出列表
2. 在 goldfish/liii/set.scm 的导出列表中添加 set-remove 与 set-remove! 函数
3. 在 tests/goldfish/liii/set-test.scm 中添加 set-remove 与 set-remove! 的文档注释和测试用例

### Why
set-remove 返回不满足 predicate 的新 set；set-remove! 提供可变版本，线性遍历并原地移除满足 predicate 的元素。

### How
1. set-remove 创建与原 set 相同比较器的新 set
2. 遍历原 set 元素，将不满足 predicate 的元素写入新 set
3. set-remove! 线性遍历并移除满足 predicate 的元素
4. 在测试中覆盖空集合与类型错误场景

## 2026/01/28 实现 set-filter 与 set-filter! 函数
### What
在 (liii set) 模块中实现 set-filter 与 set-filter! 函数，并在测试文件中新增相应的注释和测试用例。

1. 在 goldfish/srfi/srfi-113.scm 中实现 set-filter 与 set-filter! 函数并添加到导出列表
2. 在 goldfish/liii/set.scm 的导出列表中添加 set-filter 与 set-filter! 函数
3. 在 tests/goldfish/liii/set-test.scm 中添加 set-filter 与 set-filter! 的文档注释和测试用例

### Why
set-filter 用于返回满足 predicate 的新 set；set-filter! 提供可变版本，线性遍历并原地筛选元素。

### How
1. set-filter 创建与原 set 相同比较器的新 set
2. 遍历原 set 元素，满足 predicate 的元素写入新 set
3. set-filter! 收集不满足 predicate 的元素并从原 set 删除
4. 在测试中覆盖空集合与类型错误场景

## 2026/01/28 实现 set-for-each 与 set-fold 函数
### What
在 (liii set) 模块中实现 set-for-each 与 set-fold 函数，并在测试文件中新增相应的注释和测试用例。

1. 在 goldfish/srfi/srfi-113.scm 中实现 set-for-each 与 set-fold 函数并添加到导出列表
2. 在 goldfish/liii/set.scm 的导出列表中添加 set-for-each 与 set-fold 函数
3. 在 tests/goldfish/liii/set-test.scm 中添加 set-for-each 与 set-fold 的文档注释和测试用例

### Why
set-for-each 用于对 set 中元素执行副作用操作；set-fold 用于按任意顺序遍历并累积结果，提供与 list fold 类似的聚合能力。

### How
1. set-for-each 遍历 set 并对每个元素调用 proc，忽略返回值
2. set-fold 以 nil 作为初始累积值，对每个元素调用 proc 并更新累积结果
3. set 为空时，set-fold 返回 nil
4. 在测试中覆盖空集合、累积与类型错误场景

## 2026/01/28 实现 set-map 函数
### What
在 (liii set) 模块中实现 set-map 函数，并在测试文件中新增相应的注释和测试用例。

1. 在 goldfish/srfi/srfi-113.scm 中实现 set-map 函数并添加到导出列表
2. 在 goldfish/liii/set.scm 的导出列表中添加 set-map 函数
3. 在 tests/goldfish/liii/set-test.scm 中添加 set-map 的文档注释和测试用例

### Why
set-map 用于对 set 中每个元素应用映射函数并返回新的 set。映射结果会按照提供的 comparator 去重，适合做类型转换或数据归一化。

### How
1. 创建一个使用 comparator 的新 set
2. 遍历原 set 的元素，对每个元素执行 proc
3. 将映射结果加入新 set，自动去重
4. 返回新 set，并确保原 set 不变

## 2026/01/28 实现 set-search! 函数
### What
在 (liii set) 模块中实现 set-search! 函数，并在测试文件中新增相应的注释和测试用例。

1. 在 goldfish/srfi/srfi-113.scm 中实现 set-search! 函数并添加到导出列表
2. 在 goldfish/liii/set.scm 的导出列表中添加 set-search! 函数
3. 在 tests/goldfish/liii/set-test.scm 中添加 set-search! 的文档注释和测试用例

### Why
set-search! 提供基于 continuation 的可变搜索/更新能力：元素不存在时可选择插入或忽略；元素存在时可选择更新或删除，并返回 set 与 obj 两个值，便于将搜索与更新逻辑合并为一次操作。

### How
1. 使用 hash-table-ref/default 在 set 中查找元素，区分命中与未命中路径
2. 未命中时调用 failure，并提供 insert/ignore continuations
3. 命中时调用 success，并提供 update/remove continuations
4. continuations 内返回 (values set obj)，并确保在 update/remove 分支完成 set 的可变更新
5. 在测试中覆盖 insert/ignore/update/remove 与类型错误场景

## 2026/01/27 实现 set-delete 系列函数
### What
在 (liii set) 模块中实现 set-delete, set-delete!, set-delete-all, set-delete-all! 函数。

1. 在 goldfish/srfi/srfi-113.scm 中实现这四个函数并导出。
2. 在 goldfish/liii/set.scm 中导出这四个函数。
3. 在 tests/goldfish/liii/set-test.scm 中添加文档注释和测试用例。

### Why
这些函数用于从 set 中移除一个或多个元素，包括函数式（不可变）和破坏性（可变）版本，以及接受列表作为参数的版本。

### How
- `set-delete`: 复制 set，遍历参数，使用 `hash-table-delete!`。
- `set-delete!`: 直接在原 set 上遍历参数，使用 `hash-table-delete!`。
- `set-delete-all`: 同 `set-delete`，但参数为 list。
- `set-delete-all!`: 同 `set-delete!`，但参数为 list。

## 2026/01/27 实现 set-replace! 函数
### What
在 (liii set) 模块中实现 set-replace! 函数，并在测试文件中新增相应的注释和测试用例。

1. 在 goldfish/srfi/srfi-113.scm 中实现 set-replace! 函数并添加到导出列表
2. 在 goldfish/liii/set.scm 的导出列表中添加 set-replace! 函数
3. 在 tests/goldfish/liii/set-test.scm 中添加 set-replace! 的文档注释和测试用例

### Why
set-replace! 函数用于替换 set 中已存在的元素（可变操作）。

### How
1. 检查 element 是否存在于 set 中。
2. 如果存在：
   - 删除旧元素（hash-table-delete!）。
   - 添加新 element（set-add!）。
3. 如果不存在，不做任何操作。
4. 返回 set。

## 2026/01/27 实现 set-replace 函数
### What
在 (liii set) 模块中实现 set-replace 函数，并在测试文件中新增相应的注释和测试用例。

1. 在 goldfish/srfi/srfi-113.scm 中实现 set-replace 函数并添加到导出列表
2. 在 goldfish/liii/set.scm 的导出列表中添加 set-replace 函数
3. 在 tests/goldfish/liii/set-test.scm 中添加 set-replace 的文档注释和测试用例

### Why
set-replace 函数用于替换 set 中已存在的元素。这对于自定义比较器（如大小写不敏感字符串）非常有用，可以更新 set 中存储的实际值。

### How
1. 检查 element 是否存在于 set 中。
2. 如果存在：
   - 复制原 set。
   - 删除旧元素（使用 hash-table-delete! 确保 key 被移除）。
   - 添加新 element。
   - 返回新 set。
3. 如果不存在，直接返回原 set。

## 2026/01/27 实现 set-adjoin! 函数
### What
在 (liii set) 模块中实现 set-adjoin! 函数，并在测试文件中新增相应的注释和测试用例。

1. 在 goldfish/srfi/srfi-113.scm 中实现 set-adjoin! 函数并添加到导出列表
2. 在 goldfish/liii/set.scm 的导出列表中添加 set-adjoin! 函数
3. 在 tests/goldfish/liii/set-test.scm 中添加 set-adjoin! 的文档注释和测试用例

### Why
set-adjoin! 函数用于向 set 中添加一个或多个元素，并返回修改后的 set。这是 set 的破坏性更新操作，效率高于 functional update。

### How
1. 遍历参数列表中的元素。
2. 使用 `set-add!` 将每个元素直接添加到原 set 中。
3. 返回原 set。

## 2026/01/27 实现 set-adjoin 函数
### What
在 (liii set) 模块中实现 set-adjoin 函数，并在测试文件中新增相应的注释和测试用例。

1. 在 goldfish/srfi/srfi-113.scm 中实现 set-adjoin 函数并添加到导出列表
2. 在 goldfish/liii/set.scm 的导出列表中添加 set-adjoin 函数
3. 在 tests/goldfish/liii/set-test.scm 中添加 set-adjoin 的文档注释和测试用例

### Why
set-adjoin 函数用于向 set 中添加一个或多个元素，并返回一个新的 set，原 set 不变。这是 set 的函数式更新操作。

### How
1. 使用 `set-copy` 创建原 set 的副本。
2. 使用 `set-add!` 将新元素添加到副本中。
3. 返回副本。

## 2026/01/27 实现 set-member 函数
### What
在 (liii set) 模块中实现 set-member 函数，并在测试文件中新增相应的注释和测试用例。

1. 在 goldfish/srfi/srfi-113.scm 中实现 set-member 函数并添加到导出列表
2. 修改 goldfish/srfi/srfi-113.scm 中的 set-add! 函数，使其在哈希表中存储元素本身作为值，而不是固定值 1
3. 在 goldfish/liii/set.scm 的导出列表中添加 set-member 函数
4. 在 tests/goldfish/liii/set-test.scm 中添加 set-member 的文档注释和测试用例

### Why
set-member 函数用于在 set 中查找与指定元素相等的元素（可能不是同一个对象）。如果 set 底层使用哈希表，通过存储元素作为值，可以实现 O(1) 的查找。

### How
1. 修改 set-add!：`(hash-table-set! (set-hash-table s) element element)`
2. 实现 set-member：`(hash-table-ref/default (set-hash-table s) element default)`
3. 在测试中使用自定义的 hash 函数以确保 set-contains? 和 set-member 在使用自定义比较器时行为正确。

## 2026/01/27 实现 set-count 函数
### What
在 (liii set) 模块中实现 set-count 函数，并在测试文件中新增相应的注释和测试用例。

1. 在 goldfish/srfi/srfi-113.scm 中实现 set-count 函数并添加到导出列表
2. 在 goldfish/liii/set.scm 的导出列表中添加 set-count 函数
3. 在 tests/goldfish/liii/set-test.scm 中添加 set-count 的文档注释和测试用例

### Why
set-count 函数用于计算 set 中满足谓词的元素个数，这是 set 操作中常用的功能，是对 SRFI-113 的扩展。

### How
1. 在 SRFI-113 中实现 set-count 函数，使用 hash-table-for-each 遍历 set 元素并计数
2. 在 set.scm 中导入并重新导出 set-count 函数
3. 在测试文件中添加完整的文档注释和多种测试用例

## 2026/01/27 实现 set-find 函数
### What
在 (liii set) 模块中实现 set-find 函数，并在测试文件中新增相应的注释和测试用例。

1. 在 goldfish/srfi/srfi-113.scm 中实现 set-find 函数并添加到导出列表
2. 在 goldfish/liii/set.scm 的导出列表中添加 set-find 函数
3. 在 tests/goldfish/liii/set-test.scm 中添加 set-find 的文档注释和测试用例

### Why
set-find 函数用于在 set 中查找满足谓词的元素，如果找不到则调用 failure 函数，这是 set 操作中常用的功能，是对 SRFI-113 的扩展。

### How
1. 在 SRFI-113 中实现 set-find 函数，使用 hash-table-for-each 遍历 set 元素
2. 使用 call/cc 实现提前返回，当找到满足谓词的元素时立即返回该元素
3. 如果遍历完所有元素都没有找到，则调用 failure 函数
4. 在 set.scm 中导入并重新导出 set-find 函数
5. 在测试文件中添加完整的文档注释和多种测试用例

## 2026/01/27 实现 set-every? 函数
### What
在 (liii set) 模块中实现 set-every? 函数，并在测试文件中新增相应的注释和测试用例。

1. 在 goldfish/srfi/srfi-113.scm 中实现 set-every? 函数并添加到导出列表
2. 在 goldfish/liii/set.scm 的导出列表中添加 set-every? 函数
3. 在 tests/goldfish/liii/set-test.scm 中添加 set-every? 的文档注释和测试用例

### Why
set-every? 函数用于检查 set 中是否所有元素都满足给定的谓词函数，这是 set 操作中常用的功能，是对 SRFI-113 的扩展。

### How
1. 在 SRFI-113 中实现 set-every? 函数，使用 hash-table-for-each 遍历 set 元素
2. 使用 call/cc 实现提前返回，当找到不满足谓词的元素时立即返回 #f
3. 在 set.scm 中导入并重新导出 set-every? 函数
4. 在测试文件中添加完整的文档注释和多种测试用例

## 2026/01/27 实现 set-any? 函数
### What
在 (liii set) 模块中实现 set-any? 函数，并在测试文件中新增相应的注释和测试用例。

1. 在 goldfish/srfi/srfi-113.scm 中实现 set-any? 函数并添加到导出列表
2. 在 goldfish/liii/set.scm 的导出列表中添加 set-any? 函数
3. 在 tests/goldfish/liii/set-test.scm 中添加 set-any? 的文档注释和测试用例

### Why
set-any? 函数用于检查 set 中是否有元素满足给定的谓词函数，这是 set 操作中常用的功能。

### How
1. 在 SRFI-113 中实现 set-any? 函数，使用 hash-table-for-each 遍历 set 元素
2. 使用 call/cc 实现提前返回，当找到满足谓词的元素时立即返回 #t
3. 在 set.scm 中导入并重新导出 set-any? 函数
4. 在测试文件中添加完整的文档注释和多种测试用例

## 2026/01/27 在 (liii set) 中暴露 set-size
### What
在 (liii set) 模块中暴露 set-size 函数，并在测试文件中新增相应的注释和测试用例。

1. 在 goldfish/srfi/srfi-113.scm 的导出列表中添加 set-size 函数
2. 在 goldfish/liii/set.scm 的导出列表中添加 set-size 函数
3. 在 tests/goldfish/liii/set-test.scm 中添加 set-size 的文档注释和测试用例

### Why
set-size 函数已经实现但未暴露给用户使用，需要将其添加到 (liii set) 模块的公共 API 中。

### How
1. 首先在底层 SRFI-113 实现中导出 set-size 函数
2. 然后在 (liii set) 模块中导入并重新导出 set-size
3. 最后在测试文件中添加完整的文档注释和测试用例

## 2026/01/26 之前的提交和任务描述
### 2026/1/26 实现set的谓词和构造器
### 2026/1/26 将set改为rich-set
