# [210_20] 异步 HTTP API

## 任务相关的代码文件
- `src/goldfish.hpp`
- `goldfish/liii/http.scm`
- `tests/goldfish/liii/http-test.scm`
- `demo/async_http_demo.scm`
- `demo/async_vs_sync_demo.scm`
- `tests/test_all.scm`

## 如何测试

```shell
# 构建
xmake build goldfish

# 运行 HTTP 测试（单独运行）
./bin/goldfish tests/goldfish/liii/http-test.scm

# 运行所有测试（默认不包含 HTTP 测试）
./bin/goldfish tests/test_all.scm

# 运行所有测试（包含 HTTP 测试）
GOLDFISH_TEST_HTTP=1 ./bin/goldfish tests/test_all.scm

# 运行 demo
./bin/goldfish demo/async_http_demo.scm
./bin/goldfish demo/async_vs_sync_demo.scm
```

## 2026/2/13 在 test_all.scm 中默认关闭 HTTP 测试，支持通过环境变量开启

### What
1. 修改 `tests/test_all.scm`，默认排除 `http-test.scm` 测试文件
2. 通过环境变量 `GOLDFISH_TEST_HTTP` 控制是否运行 HTTP 测试
   - `GOLDFISH_TEST_HTTP=1`：启用 HTTP 测试
   - 未设置或 `GOLDFISH_TEST_HTTP=0`：禁用 HTTP 测试

### Why
HTTP 测试需要网络连接和外部服务（httpbin.org），在以下情况下可能失败：
1. 无网络环境
2. 外部服务不可用
3. CI/CD 环境网络限制

默认禁用 HTTP 测试可以确保测试套件在无网络环境下也能正常运行，同时为需要网络测试的场景提供可选开启机制。

## 2026/2/13 实现 libcpr 异步 HTTP 绑定

### What

1. 新增 C++ 层异步 HTTP 绑定：
   - `f_http_async_get` / `glue_http_async_get`：异步 GET 请求
   - `f_http_async_post` / `glue_http_async_post`：异步 POST 请求
   - `f_http_async_head` / `glue_http_async_head`：异步 HEAD 请求
   - `f_http_poll` / `glue_http_poll`：非阻塞轮询完成的请求
   - `f_http_wait_all` / `glue_http_wait_all`：阻塞等待所有请求完成

2. 新增 Scheme 层包装函数：
   - `http-async-get`：`(http-async-get url callback [params] [headers] [proxy])`
   - `http-async-post`：`(http-async-post url callback [params] [data] [headers] [proxy])`
   - `http-async-head`：`(http-async-head url callback [params] [headers] [proxy])`
   - `http-poll`：检查并执行已完成的回调
   - `http-wait-all`：`(http-wait-all [timeout])` 等待所有请求完成

3. 新增 demo 文件：
   - `demo/async_http_demo.scm`：展示基本用法、并发请求、轮询机制
   - `demo/async_vs_sync_demo.scm`：对比同步和异步请求的性能差异

4. 新增测试用例：
   - 异步 GET/POST/HEAD 测试
   - 多个并发请求测试
   - `http-poll` 返回值测试

### Why

提供真正的异步 HTTP 请求能力，使多个 HTTP 请求可以并发执行而不阻塞主线程。这对于需要同时请求多个资源的场景（如批量 API 调用、并行数据获取）可以显著提升性能。

### How

1. **使用 libcpr 原生异步 API**：通过 `session.GetAsync()`、`session.PostAsync()`、`session.HeadAsync()` 启动异步请求，利用 libcpr 内部的全局线程池执行网络 I/O。

2. **Session 生命周期管理**：使用 `std::shared_ptr<cpr::Session>` 保持 Session 对象存活，直到异步操作完成，避免 `bad_weak_ptr` 错误。

3. **线程安全的回调机制**：
   - 后台线程只负责执行 HTTP 请求，不直接调用 Scheme 回调
   - 主线程通过 `http-poll` 或 `http-wait-all` 检查完成的请求并执行回调
   - 使用 `s7_gc_protect` / `s7_gc_unprotect_at` 保护 Scheme 回调不被 GC

4. **并发执行验证**：3 个 delay/1 的请求总耗时约 2 秒（而非 6 秒），证明请求是并发执行的。
