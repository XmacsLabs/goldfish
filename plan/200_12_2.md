# Plan B: 直接修改 check 函数集成 stacktrace 支持 (200_12_2)

## 问题分析

方案A的问题：
- `check-report` 调用 `stacktrace` 时显示的调用栈来自 `check-report` 自身
- 无法正确捕获原始测试失败位置
- 需要在测试失败时立即捕获上下文，而不是在报告阶段

## 方案B核心思路

直接修改 `srfi-78.scm` 的 `check:proc` 函数，在测试失败瞬间捕获完整调用栈和位置信息，并存储在失败记录中，以便后续报告使用。

## 具体实施步骤

### Phase 1: 修改 srfi-78.scm 的核心函数

#### 1.1 增强失败记录结构

**文件**: `goldfish/srfi/srfi-78.scm`
**修改位置**: `check:add-failed!` 函数和调用点

```scheme
;; 修改失败的记录结构，增加位置信息
(define (check:add-failed! expression actual-result expected-result file line call-stack)
  (set! check:failed
        (cons (list expression actual-result expected-result file line call-stack)
              check:failed)))
```

#### 1.2 修改 check:proc 捕获位置信息

**文件**: `goldfish/srfi/srfi-78.scm`
**修改位置**: `check:proc` 函数的所有失败分支

```scheme
;; 新增位置信息捕获函数
(define (check:get-source-location expr)
  (list (pair-filename expr) (pair-line-number expr)))

;; 修改 check:proc 的实现
define* (check:proc expression thunk expected-result (equal class=?))
  (let ((location-info (check:get-source-location expression)))
    (case check:mode
      ((0) #f)
      ((1)
       (let ((actual-result (thunk)))
         (if (equal actual-result expected-result)
             (check:add-correct!)
             (let ((call-stack (stacktrace 10 45 70 45 #f)))
               (check:add-failed! expression actual-result expected-result
                                 (car location-info) (cadr location-info) call-stack)))))
      ((10)
       (let ((actual-result (thunk)))
         (if (equal actual-result expected-result)
             (check:add-correct!)
             (let ((call-stack (stacktrace 10 45 70 45 #f)))
               (begin
                 (check:report-expression expression)
                 (check:report-actual-result actual-result)
                 (check:report-failed expected-result)
                 (display "; 位置: ")
                 (display (car location-info))
                 (display ":")
                 (display (cadr location-info))
                 (newline)
                 (display "; 调用栈:")
                 (newline)
                 (display call-stack)
                 (newline)
                 (check:add-failed! expression actual-result expected-result
                                   (car location-info) (cadr location-info) call-stack))))))
      ((100)
       (check:report-expression expression)
       (let ((actual-result (thunk)))
         (check:report-actual-result actual-result)
         (if (equal actual-result expected-result)
             (begin (check:report-correct 1)
                    (check:add-correct!))
             (let ((call-stack (stacktrace 10 45 70 45 #f)))
               (begin (check:report-failed expected-result)
                      (display "; 位置: ")
                      (display (car location-info))
                      (display ":")
                      (display (cadr location-info))
                      (newline)
                      (display "; 调用栈:")
                      (newline)
                      (display call-stack)
                      (newline)
                      (check:add-failed! expression actual-result expected-result
                                        (car location-info) (cadr location-info) call-stack))))))
      (else (error "unrecognized check:mode" check:mode)))))
```

### Phase 2: 修改 check-report 使用存储的栈信息

#### 2.1 更新 check-report 函数

**文件**: `goldfish/srfi/srfi-78.scm`
**修改位置**: `check-report` 函数

```scheme
(define (check-report)
  (if (>= check:mode 1)
      (begin
        (newline)
        (display "; *** checks *** : ")
        (display check:correct)
        (display " correct, ")
        (display (length check:failed))
        (display " failed.")
        (if (or (null? check:failed) (<= check:mode 1))
            (newline)
            (let* ((w (car (reverse check:failed)))
                   (expression (car w))
                   (actual-result (cadr w))
                   (expected-result (caddr w))
                   (file (list-ref w 3))
                   (line (list-ref w 4))
                   (call-stack (list-ref w 5)))
              (display " First failed example:")
              (newline)
              (check:report-expression expression)
              (check:report-actual-result actual-result)
              (check:report-failed expected-result)
              (display "; 位置: ")
              (display file)
              (display ":")
              (display line)
              (newline)
              (display "; 调用栈:")
              (newline)
              (display call-stack)
              (newline)))))))
```

### Phase 3: 创建测试验证

#### 3.1 创建验证测试文件

**文件**: `tests/200_12_2_test.scm`

```scheme
#!/usr/bin/env goldfish

(import (liii check))

;; 测试基础功能
(define (test-basic-function)
  (+ 1 2))

;; 深度调用链测试
(define (level-3)
  (check 1 => 2))  ; 应该失败

(define (level-2)
  (level-3))

(define (level-1)
  (level-2))

;; 嵌套测试
(define (test-nested-failure)
  (let ((x 5))
    (check x => 10)))  ; 应该失败

;; 错误类型测试
(define (test-error-propagation)
  (check (car '()) => 'nil))  ; 应该捕获空列表错误

;; 文件位置测试
(display "=== 测试1: 基础调用 ===")
(newline)
(check (+ 1 1) => 3)  ; 故意失败

(display "=== 测试2: 嵌套调用 ===")
(newline)
(test-nested-failure)

(display "=== 测试3: 深度调用链 ===")  
(newline)
(level-1)

(display "=== 测试4: 错误传播 ===")
(newline)
(test-error-propagation)

;; 设置不同测试模式
(check-set-mode! 'report-failed)
(check-report)

;; 验证位置信息正确显示
(display "验证stacktrace已捕获实际测试位置而非check-report位置")
(newline)
```

### Phase 4: 兼容性验证

#### 4.1 运行所有模式测试

```bash
#!/bin/bash

# 测试脚本：验证所有模式正确工作

echo "=== 测试 off 模式 ==="
bin/goldfish -e "
(import (liii check))
(check-set-mode! 'off)
(check 1 => 2)
(check-report)
"

echo "=== 测试 summary 模式 ==="
bin/goldfish -e "
(import (liii check))
(check-set-mode! 'summary)
(check 1 => 2)
(check-report)
"

echo "=== 测试 report-failed 模式 ==="
bin/goldfish -e "
(import (liii check))
(check-set-mode! 'report-failed)
(check 1 => 2)
(check-report)
"

echo "=== 测试 report 模式 ==="
bin/goldfish -e "
(import (liii check))
(check-set-mode! 'report)
(check 1 => 2)
(check-report)
"

# 测试正常通过情况
echo "=== 测试通过情况 ==="
bin/goldfish -e "
(import (liii check))
(check-set-mode! 'report)
(check 1 => 1)
(check-report)
"
```

### Phase 5: 边界情况和性能

#### 5.1 处理异常边界条件

```scheme
;; 增强错误处理
(define (check:get-source-location expr)
  (list (or (ignore-errors (pair-filename expr)) "unknown")
        (or (ignore-errors (pair-line-number expr)) 0)))

;; 内存保护 - 限制stacktrace深度
(define (check:get-stacktrace-safely)
  (ignore-errors 
    (let ((stack (stacktrace 5 30 50 30 #f)))
      (if (and (string? stack) (> (string-length stack) 0))
          stack
          ""))))
```

#### 5.2 性能基准测试

```bash
#!/bin/bash

# 测试性能影响
echo "=== 性能基准测试 ==="

# 原始性能
time bin/goldfish tests/goldfish/liii/base-test.scm

# 增强功能对性能影响测试
time bin/goldfish tests/200_12_2_test.scm

# 大量测试场景性能
time bin/goldfish -e "
(import (liii check))
(do ((i 0 (+ i 1))) ((= i 1000))
  (check (+ i 1) => (+ i 1)))  ; 全部通过
(check-report)
"

time bin/goldfish -e "
(import (liii check))
(do ((i 0 (+ i 1))) ((= i 100))  
  (check (+ i 1) => (+ i 2)))  ; 部分失败
(check-report)
"
```

### Phase 6: 最终集成验证

#### 6.1 运行完整测试套件

```bash
#!/bin/bash

# 验证与现有代码的兼容性
bin/goldfish tests/goldfish/srfi/srfi-78-test.scm

# 测试混合测试场景
bin/goldfish tests/goldfish/liii/list-test.scm
bin/goldfish tests/goldfish/scheme/list-test.scm

# 验证文件位置准确性测试
bin/goldfish -e "
(import (liii check))
(check-set-mode! 'report-failed)
(let ((this-line (pair-line-number '(dummy))))
  (check this-line => (+ this-line 10)))  ; 故意失败，验证行号
(check-report)
"
```

## 关键差异总结

相比方案A，方案B有以下优势：

1. **位置准确性**: 直接在测试失败点捕获位置信息，避免了 check-report 的干扰
2. **栈追踪完整性**: 捕获的是原始失败点的调用栈，无检查框架的干扰
3. **保留原有API**: 保持所有check API不变，无需新增函数
4. **按需捕获**: 仅在失败时捕获stacktrace，避免额外性能开销

## 技术关键点

1. **双重位置获取**: 同时使用 `(pair-filename expr)` 和 `(pair-line-number expr)` 获取精确测试位置
2. **stacktrace捕获时机**: 在 `check:proc` 内部立即捕获，避免调用链被框架污染
3. **结构升级**: 将失败记录从 `(expr actual expected)` 扩展为 `(expr actual expected file line stack)`
4. **向后兼容**: 确保所有现有API和测试代码无需任何修改

## 交付验收标准

- [ ] 测试失败时准确显示原始测试位置的stacktrace
- [ ] 支持所有现有check模式 (off/summary/report-failed/report)
- [ ] 100%向后兼容，现有测试无需修改
- [ ] 性能开销仅在失败测试时出现，对通过测试无额外开销
- [ ] 文件位置、行号和调用栈信息完整准确