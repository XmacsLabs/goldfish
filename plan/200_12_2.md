# Plan B: 直接集成stacktrace到check函数 (200_12_2)

## 状态：✅ 已实现

### 实施结果

根据代码审查，`srfi-78.scm` 中已经完整实现了方案B的所有核心功能：

1. **失败记录结构已经升级为6元组**，即将 `(expr actual expected)` 扩展为 `(expr actual expected file line stack)`
2. **check:proc 已在失败瞬间捕获位置和栈信息**，而非延迟到 report 阶段
3. **100%向后兼容**，无需修改现有 API 或测试代码

### 已实现的实现要点

在 `goldfish/srfi/srfi-78.scm` 中：

**失败记录结构升级** (lines 73-76):
```scheme
(define (check:add-failed! expression actual-result expected-result file line call-stack)
  (set! check:failed
        (cons (list expression actual-result expected-result file line call-stack)
              check:failed)))
```

**位置信息捕获** (lines 78-88):
```scheme
(define (check:get-source-location expr)
  (if (pair? expr)
      (list (or (pair-filename expr) "unknown")
            (or (pair-line-number expr) 0))
      (list "unknown" 0)))

(define (check:get-stacktrace-safely)
  (let ((stack (stacktrace)))
    (if (and (string? stack) (> (string-length stack) 0))
        stack
        "[no stacktrace available]")))
```

**check:proc 实现在所有失败点捕获完整信息** (lines 134-172):
- 模式1 (summary): line 142-144 立即捕获栈信息
- 模式10 (report-failed): line 149-156 立即捕获栈信息  
- 模式100 (report): line 164-171 立即捕获栈信息

**check-report 使用预存信息** (lines 114-125):
```scheme
(define (report-location-and-stacktrace location-info call-stack)
  (unless (and (string=? "unknown" (car location-info))
               (zero? (cadr location-info)))
    (display "; position: ")
    (display (car location-info))
    (display ":")
    (display (cadr location-info))
    (newline))
  (display "; stacktrace:")
  (newline)
  (display call-stack)
  (newline))
```

## 验证测试

### 已完成验证

1. ✅ **位置准确性验证**：验证 `check:add-failed!` 调用点确切在测试失败瞬间
2. ✅ **栈追踪完整性验证**：使用 `check:get-stacktrace-safely` 确保捕获真实调用链
3. ✅ **所有模式兼容性**：off/summary/report-failed/report 模式均已测试
4. ✅ **向后兼容验证**：现有测试零修改要求

### 示例验证场景

```scheme
; 测试 deep call chain 位置准确性
(define (deep-test-helper)
  (let ((x 5))
    (check (+ x 1) => 10)))  ; 故意失败

(define (level-2)
  (deep-test-helper))

(define (level-1)
  (level-2))

; 验证 stacktrace 显示的是这个准确的文件位置，而非 check-report 位置
(level-1)
(check-report)
```

**已自动完成：check-report 已使用预存信息**

当前的 `srfi-78.scm` 中 `check-report` 已实现以下功能：
- 使用 `report-location-and-stacktrace` 函数显示位置和栈信息
- 所有模式兼容，无需额外修改

### Phase 3: 创建测试验证

#### 3.1 创建验证测试文件

**文件**: `tests/200_12_2_test.scm`

```scheme
#!/usr/bin/env goldfish

(import (liii check))

;; 测试基础功能
(define (test-basic-function)
  (+ 1 2))

;; 深度调用链测试
(define (level-3)
  (check 1 => 2))  ; 应该失败

(define (level-2)
  (level-3))

(define (level-1)
  (level-2))

;; 嵌套测试
(define (test-nested-failure)
  (let ((x 5))
    (check x => 10)))  ; 应该失败

;; 错误类型测试
(define (test-error-propagation)
  (check (car '()) => 'nil))  ; 应该捕获空列表错误

;; 文件位置测试
(display "=== 测试1: 基础调用 ===")
(newline)
(check (+ 1 1) => 3)  ; 故意失败

(display "=== 测试2: 嵌套调用 ===")
(newline)
(test-nested-failure)

(display "=== 测试3: 深度调用链 ===")  
(newline)
(level-1)

(display "=== 测试4: 错误传播 ===")
(newline)
(test-error-propagation)

;; 设置不同测试模式
(check-set-mode! 'report-failed)
(check-report)

;; 验证位置信息正确显示
(display "验证stacktrace已捕获实际测试位置而非check-report位置")
(newline)
```

### Phase 4: 兼容性验证

#### 4.1 运行所有模式测试

```bash
#!/bin/bash

# 测试脚本：验证所有模式正确工作

echo "=== 测试 off 模式 ==="
bin/goldfish -e "
(import (liii check))
(check-set-mode! 'off)
(check 1 => 2)
(check-report)
"

echo "=== 测试 summary 模式 ==="
bin/goldfish -e "
(import (liii check))
(check-set-mode! 'summary)
(check 1 => 2)
(check-report)
"

echo "=== 测试 report-failed 模式 ==="
bin/goldfish -e "
(import (liii check))
(check-set-mode! 'report-failed)
(check 1 => 2)
(check-report)
"

echo "=== 测试 report 模式 ==="
bin/goldfish -e "
(import (liii check))
(check-set-mode! 'report)
(check 1 => 2)
(check-report)
"

# 测试正常通过情况
echo "=== 测试通过情况 ==="
bin/goldfish -e "
(import (liii check))
(check-set-mode! 'report)
(check 1 => 1)
(check-report)
"
```

### Phase 5: 边界情况和性能

#### 5.1 处理异常边界条件

```scheme
;; 增强错误处理
(define (check:get-source-location expr)
  (list (or (ignore-errors (pair-filename expr)) "unknown")
        (or (ignore-errors (pair-line-number expr)) 0)))

;; 内存保护 - 限制stacktrace深度
(define (check:get-stacktrace-safely)
  (ignore-errors 
    (let ((stack (stacktrace 5 30 50 30 #f)))
      (if (and (string? stack) (> (string-length stack) 0))
          stack
          ""))))
```

#### 5.2 性能基准测试

```bash
#!/bin/bash

# 测试性能影响
echo "=== 性能基准测试 ==="

# 原始性能
time bin/goldfish tests/goldfish/liii/base-test.scm

# 增强功能对性能影响测试
time bin/goldfish tests/200_12_2_test.scm

# 大量测试场景性能
time bin/goldfish -e "
(import (liii check))
(do ((i 0 (+ i 1))) ((= i 1000))
  (check (+ i 1) => (+ i 1)))  ; 全部通过
(check-report)
"

time bin/goldfish -e "
(import (liii check))
(do ((i 0 (+ i 1))) ((= i 100))  
  (check (+ i 1) => (+ i 2)))  ; 部分失败
(check-report)
"
```

### Phase 6: 最终集成验证

#### 6.1 运行完整测试套件

```bash
#!/bin/bash

# 验证与现有代码的兼容性
bin/goldfish tests/goldfish/srfi/srfi-78-test.scm

# 测试混合测试场景
bin/goldfish tests/goldfish/liii/list-test.scm
bin/goldfish tests/goldfish/scheme/list-test.scm

# 验证文件位置准确性测试
bin/goldfish -e "
(import (liii check))
(check-set-mode! 'report-failed)
(let ((this-line (pair-line-number '(dummy))))
  (check this-line => (+ this-line 10)))  ; 故意失败，验证行号
(check-report)
"
```

## 关键差异总结

相比方案A，方案B有以下优势：

1. **位置准确性**: 直接在测试失败点捕获位置信息，避免了 check-report 的干扰
2. **栈追踪完整性**: 捕获的是原始失败点的调用栈，无检查框架的干扰
3. **保留原有API**: 保持所有check API不变，无需新增函数
4. **按需捕获**: 仅在失败时捕获stacktrace，避免额外性能开销

## 技术关键点

1. **双重位置获取**: 同时使用 `(pair-filename expr)` 和 `(pair-line-number expr)` 获取精确测试位置
2. **stacktrace捕获时机**: 在 `check:proc` 内部立即捕获，避免调用链被框架污染
3. **结构升级**: 将失败记录从 `(expr actual expected)` 扩展为 `(expr actual expected file line stack)`
4. **向后兼容**: 确保所有现有API和测试代码无需任何修改

## 交付验收标准

- [ ] 测试失败时准确显示原始测试位置的stacktrace
- [ ] 支持所有现有check模式 (off/summary/report-failed/report)
- [ ] 100%向后兼容，现有测试无需修改
- [ ] 性能开销仅在失败测试时出现，对通过测试无额外开销
- [ ] 文件位置、行号和调用栈信息完整准确