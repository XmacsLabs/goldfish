# Goldfish 协程设计文档

## 当前实现

### 架构图

```
┌─────────────────────────────────────────────────────────────┐
│                      主线程 (Main Thread)                    │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Scheme 代码执行环境                     │   │
│  │  • 所有 s7_call() 在这里执行                        │   │
│  │  • 保证线程安全（无竞争条件）                        │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│  ┌───────────────────────┼───────────────────────┐         │
│  │                       │                       │         │
│  ▼                       ▼                       ▼         │
│ g_coroutine-run    g_http-async-get      g_coroutine-wait  │
│ (任务队列)            (I/O 并发)            (处理回调)      │
└─────────────────────────────────────────────────────────────┘
                           │
                           │ marl::schedule()
                           ▼
┌─────────────────────────────────────────────────────────────┐
│              marl 调度器 (4 个 worker 线程)                  │
│                                                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │  Fiber 1    │  │  Fiber 2    │  │  Fiber 3 (HTTP)     │ │
│  │ g_coroutine │  │ g_coroutine │  │ future->get()       │ │
│  │ -sleep 等待 │  │ -sleep 等待 │  │ 等待 HTTP 响应       │ │
│  └─────────────┘  └─────────────┘  └─────────────────────┘ │
│                                                             │
│  • Fiber 可以在 I/O 等待时让出执行权                        │
│  • 但 Scheme 代码始终在主线程执行                           │
└─────────────────────────────────────────────────────────────┘
```

## 两个层面的"异步"

### 1. Scheme 代码层面（当前：顺序）

```scheme
(g_coroutine-run (lambda () (do-work-1)))  ; 加入队列
(g_coroutine-run (lambda () (do-work-2)))  ; 加入队列
(g_coroutine-wait)                          ; 顺序执行
```

**结果**: work-1 和 work-2 在主线程顺序执行

### 2. C++ I/O 层面（真正并发）

```scheme
(g_http-async-get url1 '() callback1)  ; 创建 fiber，立即返回
(g_http-async-get url2 '() callback2)  ; 创建 fiber，立即返回
(g_coroutine-sleep 0.1)                ; 让出，允许 fiber 运行
(g_coroutine-wait)                      ; 处理完成的回调
```

**结果**: HTTP 请求在后台并发执行

## 结论

Goldfish 的协程设计是：**Scheme 代码单线程，C++ I/O 多线程并发**。

这是为了平衡：
- 安全性（避免 s7 线程问题）
- 实用性（HTTP 并发是最常见的需求）
- 简单性（不需要复杂的锁机制）
